#pragma once

namespace rust_compiler::ast {

class TypePathSegmentFunction;
class QualifiedPathInExpression;
class QualifiedPathInType;
class LiteralExpr;
class MetaItemPathLit;
class MetaItemLitExpr;
class TypePath;
class MetaItemLitExpr;
class AttrInputLiteral;
class BorrowExpr;
class DereferenceExpr;
class ErrorPropagationExpr;
class ArithmeticOrLogicalExpr;
class ComparisonExpr;
class LazyBooleanExpr;
class CompoundAssignmentExpr;
class GroupedExpr;
class ArrayElemsValues;
class ArrayIndexExpr;
class ArrayExpr;
class AssignmentExpr;
class TypeCastExpr;
class NegationExpr;
class TupleExpr;
class TupleIndexExpr;
class StructExprStruct;
class StructExprFieldIndexValue;
class StructExprFieldIdentifierValue;
class StructExprFieldIdentifier;
class MethodCallExpr;
class StructExprStructBase;
class ClosureExprInnerTyped;
class StructExprStructFields;
class ContinueExpr;
class FieldAccessExpr;
class CallExpr;
class ArrayElemsCopied;
class RangeFromToExpr;
class RangeToExpr;
class RangeFullExpr;
class RangeFromToInclExpr;
class RangeToInclExpr;
class RangeFromExpr;
class UnsafeBlockExpr;
class ReturnExpr;
class LoopExpr;
class ForLoopExpr;
class WhileLoopExpr;
class WhileLetLoopExpr;
class BreakExpr;
class IfExprConseqElse;
class IfExprConseqIf;
class IfLetExpr;
class IfExpr;
class IfExprConseqIfLet;
class IfLetExprConseqIf;
class IfLetExprConseqIfLet;
class MatchExpr;
class AwaitExpr;
class TypeParam;
class AsyncBlockExpr;
class BlockExpr;
class ClosureExprInner;
class TypePathSegmentGeneric;
class TypePathSegment;
class PathInExpression;
class ConstGenericParam;
class LifetimeParam;
class Lifetime;
class IdentifierExpr;
class AttrInputMetaItemContainer;
class DelimTokenTree;
class Token;
class EnumItemTuple;
class EnumItem;
class TupleStruct;
class TypeAlias;
class Function;
class UseDeclaration;
class UseTreeRebind;
class UseTreeList;
class UseTreeGlob;
class ExternCrate;
class Module;
class Method;
class TypeBoundWhereClauseItem;
class LifetimeWhereClauseItem;
class EnumItemTuple;
class EnumItem;
class TupleStruct;
class TupleStruct;
class EnumItem;
class EnumItemTuple;
class TraitItemConst;
class TraitItemMethod;
class TraitItemFunc;
class StaticItem;
class ConstantItem;
class TraitItemType;
class Union;
class InherentImpl;
class Trait;
class MetaItemPathLit;
class MacroInvocation;
class MacroRulesDefinition;
class MacroMatcher;
class MacroMatchRepetition;
class MacroMatchFragment;
class ExternBlock;
class ExternalFunctionItem;
class ExternalStaticItem;
class TraitImpl;
class EnumItemDiscriminant;
class EnumItemStruct;
class RangePatternBoundPath;
class RangePatternBoundLiteral;
class WildcardPattern;
class IdentifierPattern;
class LiteralPattern;
class MetaListNameValueStr;
class MetaListPaths;
class MetaNameValueStr;
class MetaWord;
class MetaItemSeq;
class TupleStructItemsRange;
class TupleStructItemsNoRange;
class StructPattern;
class StructPatternFieldIdent;
class StructPatternFieldIdentPat;
class StructPatternFieldTuplePat;
class ReferencePattern;
class RangePattern;
class GroupedPattern;
class TuplePattern;
class LetStmt;
class EmptyStmt;
class SlicePattern;
class TraitBound;
class ExprStmtWithBlock;
class ExprStmtWithoutBlock;
class ImplTraitType;
class ParenthesisedType;
class TraitObjectType;
class TupleType;
class TuplePatternItemsRanged;
class RawPointerType;
class NeverType;
class TraitObjectTypeOneBound;
class ImplTraitTypeOneBound;
class SliceType;
class ReferenceType;
class BareFunctionType;
class InferredType;
class ArrayType;
class SimplePath;
class TuplePatternItemsMultiple;
class TupleStructPattern;
class RangePatternBoundQualPath;
class MetaItemPath;
  class Enum;
  class IfLetExprConseqElse;
  class StructStruct;
  
} // namespace rust_compiler::ast
